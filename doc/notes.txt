partie 2: chargement dans la base de données

modification des données :

	les données de comment.csv présentent le problème suivant : 
		dans le champ "body" est contenu le texte du commentaire, cependant ce champ contient de nombreux doubles retours chariots
		ainsi, lors de la lecture de la table, ces retours chariots posent problèmes et le champ "body" doit être nettoyé

	pour ce faire, le script python clean_comment.py permet:
		de supprimer tous les retours chariots
		de créer de nouveaux retours chariots à la fin du champ "subreddit_id"
		ceci est possible car le subreddit_id est toujours le même (les données concernent uniquement le subreddit "AskReddit")

	un problème commun avec toutes les tables est l'importation des headers dans la base de données SQLite 
		- les headers sont considérés comme des données
		- en ligne de commande (dans le dossier data_base/data)
			$ python3
			>>> with open("tables/askreddit_author.csv", "r") as f:
			... 	  with open("clean_tables/clean_author.csv", "w") as g:
			... 		next(f)
			... 		for line in f:
			... 		       g.write(line)
			>>> 

		- source : https://stackoverflow.com/questions/23615496/removing-the-first-line-of-csv-file
		- ce code est répété pour les tables d'origine
		- les tables nettoyés des headers sont placées dans le fichier clean_tables/

	les données sont donc réparties dans deux fichiers : 
		
		- dans le fichier tables/ est contenu les données d'origine, extraitent directement du fichier .zip
		- dans le fichier clean_tables/ est contenu les données sans la ligne header (noms des variables)

		
			
importation des données dans la base de données SQLite :

	
		$ cd Documents/dev/data_base
		$ sqlite3 "project.db"
		
		sqlite> .cd logic
		sqlite> .read script_part1.sql
		sqlite> .tables
		
		sqlite> .mode csv
		sqlite> .separator ","

		sqlite> .import /home/use/Documents/dev/data_base/data/clean_tables/clean_author.csv author_
		sqlite> .import /home/use/Documents/dev/data_base/data/clean_tables/clean_distinguihshed.csv distinguihshed_
		sqlite> .import /home/use/Documents/dev/data_base/data/clean_tables/clean_controverse.csv controversy_
		sqlite> .import /home/use/Documments/dev/data_base/data/clean_tables/clean_removal.csv removal_
		sqlite> .import /home/use/Documments/dev/data_base/data/clean_tables/clean_parent.csv parent_
		sqlite> .import /home/use/Documments/dev/data_base/data/clean_tables/clean_subreddit.csv subreddit_
		sqlite> .import /home/use/Documments/dev/data_base/data/clean_tables/clean_comment.csv comment_
		sqlite> .import /home/use/Documments/dev/data_base/data/clean_tables/clean_score.csv score_
		sqlite> .import /home/use/Documments/dev/data_base/data/clean_tables/clean_is_dist.csv is_distinguished_
		sqlite> .import /home/use/Documments/dev/data_base/data/clean_tables/clean_depends.csv depends_
		-- no data about removed_


		sqlite> .indexes

partie 3: exploration initiale de la base de données :

		$ sqlite3_analyzer "project.db"

		$ sqlite3 
		sqlite> .open "project.db"

		sqlite> select count(*) from comment_;
		4234971 (+1 car la première ligne est vide)					

		sqlite> select count(*) from comment_ where id != '';
		4234970 

		un commentaire possède forcément un id donc une ligne vide (i.e. la première) possède forcément le champ vide id vide
		source : https://stackoverflow.com/questions/50679272/how-do-i-count-the-rows-that-are-not-empty-with-group-by-in-pythons-sqlite3
		
		sqlite> select count(*) from author_;
		570735

		sqlite> select count(*) from parent_;
		1464558

		sqlite> select count(*) from score_;
		4234970 

		sqlite> select count(*) from depends_;
		4234970 

		sqlite> select count(*) from is_distinguished_
		4234970 

		
partie 4: exploration approfondie de la base de données :

		sqlite> select id, max(score) from score_;
		cr56nez | 6761

		-- get comment with highest score
		sqlite> select c.id, c.body, s_max.max_score from comment_ c, (select id as id_score, max(score) as max_score from score_) s_max where s_max.id_score = c.id;
		
		-- get top 5 authors with the most number of comments
		sqlite> select a_c.* from (select author, count(author) as count_author from comment_ group by author) a_c order by a_c.count_author desc limit 5;
		
		-- 2 first authors are [deleted] and AutoModerator, we need to remove them

		sqlite> 

		-- get average score of the one who publish the most
		